
<p>Привет!</p>
<p>Вы уже изучили блок «Системы управления версиями», и начиная с этого занятия все ваши работы будут приниматься ссылками на .md-файлы.</p>
<hr>
<h1><a id="user-content-домашнее-задание-к-занятию-41-командная-оболочка-bash-практические-навыки" class="anchor" aria-hidden="true" href="#домашнее-задание-к-занятию-41-командная-оболочка-bash-практические-навыки"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Домашнее задание к занятию "4.1. Командная оболочка Bash: Практические навыки"</h1>
<h2><a id="user-content-обязательные-задания" class="anchor" aria-hidden="true" href="#обязательные-задания"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Обязательные задания</h2>
<ol>
<li>
<p>Есть скрипт:</p>
<div class="highlight highlight-source-shell position-relative overflow-auto" data-snippet-clipboard-copy-content="a=1
b=2
c=a+b
d=$a+$b
e=$(($a+$b))
"><pre>a=1
b=2
c=a+b
d=$a+$b
e=$(($a+$b))
<ul>
<li>Какие значения переменным c,d,e будут присвоены?</li>
<li>Почему?</li>
</ul>

<code>
echo c$
a+b
</code>






Потому что, a+b просто текстовая конструкция. а переменные вызываются через $


<p>echo d$
<p>1+2
<p>Потому что bash подставил значения переменных, но не увидел математического действия а всего лишь строку
<p>echo $e
<p>3
<p> Потому что, в этом случае bash увидел математическое действие. Как и в случае использования [] вместо (())
</li>
</ul>
<li>
<p>На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным. В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:
<p>while ((1==1)</p>
<p>do</p>
<p>curl https://localhost:4757</p>
<p> if (($? != 0))</p>
<p>then</p>
<p>date >> curl.log</p>
<p>fi</p>
<p>done</p>
<p>Не закрыта скобка в первой строке. добавляем и все будет работать.
<p>Тут можно придумать кучу вариантов, например:
<p>вместо date >> curl.log пишем date > curl.log и log файл будет всегда содержать последний результат curl, до того момента пока не подниместся сервис на порту 4757</p>
</li>
<li>
<p>Необходимо написать скрипт, который проверяет доступность трёх IP: 192.168.0.1, 173.194.222.113, 87.250.250.242 по 80 порту и записывает результат в файл log. Проверять доступностьп необходимо пять раз для каждого узла.</p>
<p>#Открываем цикл из 5 итераций
<p>for ((count = 0 ; count < 5; count++))
<p>do
<p> #Создаем массив из проверяемых IP адресов
<p>        declare -a addr=(192.168.62.50 192.168.62.56 192.168.62.45)
<p>#Создаем цикл, который проверяет доступность адресов по 80 порту (порт по умолчанию, поэтому не указывается) и записывает резульат в файл.
<p>        for i in ${addr[@]}
<p>        do
<p>                curl http://$i:80 > /dev/null
<p>                if (($? == 0))
<p>                then
<p>                        echo $i Available>>curl.log
<p>                else
<p>                        echo $i Unavailable>>curl.log
<p>                fi
<p>        done
<p>done
</li>
<li>
<p>Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается</p>
<p>#Задаем условие непрерывности
<p>for ((1==1))
<p>do
<p> #Создаем массив из проверяемых IP адресов
<p>        declare -a addr=(192.168.62.50 192.168.62.56 192.168.62.45)
<p>#Создаем цикл, который проверяет доступность адресов по 80 порту (порт по умолчанию, поэтому не указывается)
<p>        for i in ${addr[@]}
<p>        do
<p>                curl http://$i:80 > /dev/null
<p>#В случае отрицательного результата:
<p>                if (($? != 0))
<p>                then
<p>#Записываем IP адрес в лог
<p>                        echo $i>curl.log
<p>#И прерываем выполнение всех уровней циклов (в нашем случае трех)
<p>                        break 3
<p>                fi
<p>        done
<p>done
</li>
