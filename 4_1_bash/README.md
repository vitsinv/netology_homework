
<p>Привет!</p>
<p>Вы уже изучили блок «Системы управления версиями», и начиная с этого занятия все ваши работы будут приниматься ссылками на .md-файлы.</p>
<hr>
<h1><a id="user-content-домашнее-задание-к-занятию-41-командная-оболочка-bash-практические-навыки" class="anchor" aria-hidden="true" href="#домашнее-задание-к-занятию-41-командная-оболочка-bash-практические-навыки"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Домашнее задание к занятию "4.1. Командная оболочка Bash: Практические навыки"</h1>
<h2><a id="user-content-обязательные-задания" class="anchor" aria-hidden="true" href="#обязательные-задания"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Обязательные задания</h2>
<ol>
<li>
<p>Есть скрипт:</p>
<div class="highlight highlight-source-shell position-relative overflow-auto" data-snippet-clipboard-copy-content="a=1
b=2
c=a+b
d=$a+$b
e=$(($a+$b))
"><pre>a=1
b=2
c=a+b
d=$a+$b
e=$(($a+$b))
<ul>
<li>Какие значения переменным c,d,e будут присвоены?</li>
<li>Почему?</li>
</div>
</ul>
<p>Ответы:</p>

-    Значение переменной c:
```bash
    echo c$
    a+b
```
Потому что, a+b просто текстовая конструкция. а переменные вызываются через $

-    Значение переменной d:
```bash
    echo d$
    1+2
```
<p>Потому что bash подставил значения переменных, но не увидел математического действия а всего лишь строку</p>

-    Значение переменной e:
```bash
echo $e
3
```

<p> Потому что, в этом случае bash увидел математическое действие. Как и в случае использования [ ] вместо (( ))
</li>
</ul>
<li>
<p>На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным. В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:

```bash
    while ((1==1)
    do
    curl https://localhost:4757
    if (($? != 0))
    then
        date >> curl.log
    done
```

* Не закрыта скобка в первой строке. добавляем и все будет работать.
* Вместо `date >> curl.log` пишем `date > curl.log` и log файл будет всегда содержать последний результат curl, кроме тех случаев когда сервис на порту 4757 ответит.
* Как вариант можно добавить условие выхода из цикла, например в случае ответа сервиса. 
```bash
    if (($? != 0))
    then
        date >> curl.log
    else
        exit
```
    


<li>
<p>Необходимо написать скрипт, который проверяет доступность трёх IP: 192.168.0.1, 173.194.222.113, 87.250.250.242 по 80 порту и записывает результат в файл log. Проверять доступностьп необходимо пять раз для каждого узла.</p>

```bash
    #Открываем цикл из 5 итераций
    for ((count = 0 ; count < 5; count++))
    do
    #Создаем массив из проверяемых IP адресов
       declare -a addr=(192.168.62.50 192.168.62.56 192.168.62.45)
    #Создаем цикл, который проверяет доступность адресов по 80 порту (порт по умолчанию, поэтому можно не указывать, но для наглядности пусть будет) и записывает результат в файл.
        for i in ${addr[@]}
        do
            curl http://$i:80 > /dev/null
            if (($? == 0))
            then
                echo $i Available>>curl.log
            else
                echo $i Unavailable>>curl.log
            fi
        done
    done
```
</li>
<li>
<p>Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается</p>

```bash
    #Задаем условие непрерывности
    for ((1==1))
    do
    #Создаем массив из проверяемых IP адресов
       declare -a addr=(192.168.62.50 192.168.62.56 192.168.62.45)
    #Создаем цикл, который проверяет доступность адресов по 80 порту (порт по умолчанию, поэтому не указывается)
        for i in ${addr[@]}
        do
            curl http://$i > /dev/null
    #В случае отрицательного результата:
                if (($? != 0))
                then
    #Записываем IP адрес в лог
                    echo $i>curl.log
    #И прерываем выполнение всех уровней циклов (в нашем случае трех)
                    break 3
                fi
        done
    done

